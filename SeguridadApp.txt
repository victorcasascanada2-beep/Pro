import streamlit as st
from PIL import Image
from streamlit_js_eval import get_geolocation
import ia_engine
import html_generator
import google_drive_manager
import location_manager
import os
def login():
    if "autenticado" not in st.session_state:
        st.session_state.autenticado = False

    if not st.session_state.autenticado:
        st.container()
        st.title("üîê Acceso Tasador")
        user_id = st.text_input("ID John Deere (Ej: JD123)")
        password = st.text_input("Contrase√±a", type="password")
        
        if st.button("Entrar", use_container_width=True):
            # Buscamos en los secretos del PC
            if "usuarios" in st.secrets and user_id in st.secrets["usuarios"]:
                if password == st.secrets["usuarios"][user_id]:
                    st.session_state.autenticado = True
                    st.session_state.vendedor_id = user_id
                    st.rerun()
                else:
                    st.error("‚ùå Contrase√±a incorrecta")
            else:
                st.error("‚ùå ID de usuario no autorizado")
        return False
    return True

# Solo ejecutamos la app si el login es exitoso
if login():
# -------------------------------------------------
# 1. CONFIGURACI√ìN
# -------------------------------------------------
st.set_page_config(page_title="Tasador Agr√≠cola", page_icon="üöú", layout="centered")

# -------------------------------------------------
# 2. CSS "MODO APP NATIVA" (Sin barras ni huecos)
# -------------------------------------------------
st.markdown("""
<style>
    /* 1. Desaparece todo lo de Streamlit */
    header[data-testid="stHeader"] { display: none !important; }
    [data-testid="stToolbar"] { display: none !important; }
    footer { display: none !important; }
    
    /* 2. CONTENEDOR PRINCIPAL: PEGADO AL TECHO */
    .block-container { 
        margin-top: -3rem !important; /* Absorbe el hueco fantasma */
        padding-top: 1rem !important; /* Espacio de seguridad m√≠nimo */
        padding-bottom: 2rem !important;
        padding-left: 1rem !important;
        padding-right: 1rem !important;
    }
    
    /* 3. LOGO Y BOTONES */
    [data-testid="stImage"] { display: flex; justify-content: center; }
    
    /* Bot√≥n de Tasar m√°s visible */
    button[kind="secondaryFormSubmit"] {
        border: 2px solid #2e7d32 !important;
        color: #2e7d32 !important;
        font-weight: bold !important;
    }
</style>
""", unsafe_allow_html=True)

# -------------------------------------------------
# 3. UBICACI√ìN (ARQUITECTURA "DONDEESTOY")
# -------------------------------------------------
loc = get_geolocation(component_key="gps_tasacion_final")
texto_ubicacion = "PENDIENTE"

if loc and isinstance(loc, dict) and 'coords' in loc:
    lat = loc['coords']['latitude']
    lon = loc['coords']['longitude']
    # Formateo simple a Base64
    texto_ubicacion = location_manager.codificar_coordenadas(lat, lon)

# -------------------------------------------------
# 4. CONEXI√ìN GOOGLE
# -------------------------------------------------
if "vertex_client" not in st.session_state:
    try:
        creds = dict(st.secrets["google"])
        st.session_state.vertex_client = ia_engine.conectar_vertex(creds)
    except Exception as e:
        st.error(f"Error credenciales: {e}")

# -------------------------------------------------
# 5. INTERFAZ (LOGO BLINDADO)
# -------------------------------------------------
if os.path.exists("agricolanoroestelogo.jpg"):
    st.image("agricolanoroestelogo.jpg", width=300)
else:
    try:
        st.image("agricolanoroestelogo.jpg", width=300)
    except:
        st.warning("‚ö†Ô∏è Logo no cargado, sistema operativo.")

st.title("Tasaci√≥n Experta")

# -------------------------------------------------
# 6. FORMULARIO (OPTIMIZADO: FOTOS PRIMERO)
# -------------------------------------------------
if "informe_final" not in st.session_state:
    with st.form("form_tasacion"):
        
        # --- ZONA DE CARGA (PRIMERO) ---
        # Ponemos esto arriba para aprovechar el tiempo mientras el usuario escribe
        st.caption("üì∏ **Sube las fotos ahora** para que se carguen mientras rellenas los datos.")
        fotos = st.file_uploader("Im√°genes del veh√≠culo", accept_multiple_files=True, type=['jpg','png'])
        
        st.divider() # Separador visual para que quede ordenado
        
        # --- ZONA DE DATOS ---
        c1, c2 = st.columns(2)
        with c1:
            marca = st.text_input("Marca", value="John Deere")
            #modelo = st.text_input("Modelo", placeholder="Ej: 6155R")
        modelo = st.text_input("Modelo", value="6175M")
        with c2:
            anio = st.text_input("A√±o", value="2015")
            horas = st.text_input("Horas", value="9800")
        
        obs = st.text_area("Observaciones / Extras", value="Ruedas al 80%, Soportes de pala y monomando, compresor de aire para frenos de remolque")
        
        # BOT√ìN DE ENV√çO
        submit = st.form_submit_button("üöÄ TASAR AHORA", use_container_width=True)

   # ... (Todo tu CSS e inicializaci√≥n igual)

    # L√≥gica de procesado
    if submit:
        if marca and modelo and fotos:
            # Quitamos el spinner global y dejamos que ia_engine gestione los mensajes de etapa
            # con el st.empty() que hemos configurado dentro.
            
            try:
                # 1. Generamos el ID
                notas_ia = f"{obs}\n\n[ID_VERIFICACI√ìN: {texto_ubicacion}]"
                
                # 2. Llamada a la IA (Ahora gestiona las 4 etapas internamente)
                inf = ia_engine.realizar_peritaje(
                    st.session_state.vertex_client,
                    marca, modelo, int(anio), int(horas),
                    notas_ia, fotos
                )
                
                # 3. Guardamos sesi√≥n y generamos HTML (Igual que antes)
                st.session_state.informe_final = inf
                st.session_state.fotos_final = [Image.open(f) for f in fotos]
                st.session_state.marca = marca
                st.session_state.modelo = modelo
                
                html_final = html_generator.generar_informe_html(
                    marca, modelo, inf, st.session_state.fotos_final, texto_ubicacion
                )
                st.session_state.html = html_final
                
                # Subida a Drive
                creds = dict(st.secrets["google"])
                nombre_archivo = f"Tasacion_{marca}_{modelo}.html"
                google_drive_manager.subir_informe(creds, nombre_archivo, html_final)
                st.session_state.drive_status = "‚úÖ Informe guardado en la nube"

                st.rerun()
                
            except Exception as e:
                st.error(f"Error en el proceso: {e}")
# ... (Resto del c√≥digo igual)
        else:
            st.warning("‚ö†Ô∏è Faltan datos: Aseg√∫rate de poner Marca, Modelo y Fotos.")

# -------------------------------------------------
# 7. RESULTADOS
# -------------------------------------------------
if "informe_final" in st.session_state:
    if "drive_status" in st.session_state:
        st.caption(st.session_state.drive_status)

    st.markdown(st.session_state.informe_final)
    st.divider()
    
    c1, c2 = st.columns(2)
    
    with c1:
        st.download_button(
            "üì• DESCARGAR", 
            data=st.session_state.html, 
            file_name=f"Tasacion_{st.session_state.marca}.html",
            mime="text/html",
            use_container_width=True
        )
            
    with c2:
        if st.button("üîÑ NUEVA", use_container_width=True):
            st.session_state.clear()
            st.rerun()
